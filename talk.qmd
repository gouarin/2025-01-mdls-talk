---
title:  Towards a new vision of mesh adaptation methods and its impact on the simulation of PDEs
author:
    - Lo√Øc Gouarin
    - Marc Massot
format:
  revealjs:
    css: css/light.css
resources:
  - videos/**
highlight-style: github
footer: "Maison de la Simulation - 21 janvier 2025 - cc-by"
---


# Context

```{=html}
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
```

---

:::{.text-center}
```{=html}
<video data-autoplay src="videos/upwind_without_portion.mp4" />
```
:::

---

![](figures/compression.png){fig-align=center}

# Adaptive mesh refinement software

## Mesh adaptation

::: {.row}

:::: {.col-6}
![](figures/patch_based.png)
::::

:::: {.col}
![](figures/cell_based.png)
::::
:::

---

![](figures/amr-charac.png)

## Open source software

::: {.fs-6}
| Name    | Data structure | Adaptation criteria | Time scheme                     | Load balancing               |
|---------|----------------|---------------------|---------------------------------|------------------------------|
| AMReX   | block          | heuristic           | global/local                    | SFC                          |
| Dendro  | tree           | wavelet             | global                          | SFC                          |
| Dyablo  | tree           | heuristic           | global                          | SFC                          |
| Peano   | tree           | -                   | -                               | SFC                          |
| P4est   | tree           | -                   | -                               | SFC                          |
| samurai | interval       | heuristic/wavelet   | RK/splitting/IMEX<br>time-space/code coupling               | SFC/diffusion algorithm      |
:::

. . .

::: {.text-center .color_0 }
*samurai: create a unified framework for testing a whole range<br class='m-0'>of mesh adaptation methods with the latest generation of numerical schemes.*
:::

---

<div style="position: absolute; top: 50%; transform: translate(0, -50%); text-align: center;">

:::{.row}
::::{.col-6 .align-self-center}
![](figures/logo.png)
::::
::::{.col .align-self-center}
<h4>samurai</h4>
::::
:::
</div>

## Design principles

<div style="position: absolute; top: 50%; transform: translate(0%, -50%); text-align: center;">

- Compress the mesh according to the level-wise spatial connectivity along each Cartesian axis.
- Achieve fast look-up for a cell into the structure, especially for parents and neighbors.
- Maximize the memory contiguity of the stored data to allow for caching and vectorization.
- Facilitate inter-level operations which are common in many numerical techniques.
</div>
## An overview of the data structure

::: {.row}

:::: {.col-5}
![](figures/2d_example.png)
::::

:::: {.col .text-center .align-self-center}
<span class="interval_symb">[</span>
<span class="interval_bound">start</span>
<span class="interval_symb">,</span>
<span class="interval_bound">end</span>
<span class="interval_symb">[ @ </span>
<span class="interval_offset">offset</span>
::::

:::

## An overview of the data structure

::: {.row}

:::: {.col-4}
![](figures/2d_example.png)
::::

```{=html}
{{< include codes/celllist.html >}}
```

:::

## An overview of the data structure

::: {.row}
:::: {.col-4}
![](figures/2d_example_numbering.png)
::::
```{=html}
{{< include codes/cellarray.html >}}
```
:::

## Mesh constraints

- A refined cell is split into 2 in 1d, 4 in 2d and 8 in 3d equal parts.
- At a given resolution level, the size of the cells is equal.
- The size of the cells is defined by the resolution level.
$$\Delta x = 2^{-level}$$
- A cell is represented by integer coordinates given its location.
$$center = \Delta x (indices + 0.5)$$
- The adapted mesh is generally graded.


## Identify the different types of cells

```{=html}
<video data-autoplay src="videos/identify_0000.mp4" />
```

## Identify the different types of cells

```{=html}
<video data-autoplay src="videos/identify_0001.mp4" />
```

## Identify the different types of cells

```{=html}
<video data-autoplay src="videos/identify_0002.mp4" />
```

## Identify the different types of cells

```{=html}
<video data-autoplay src="videos/identify_0003.mp4" />
```

## Algebra of sets

:::{.text-center}
<img class="border border-2" src="figures/mesh.png" width="400px"/><span>&#8899;</span>
<img class="border border-2" src="figures/mesh_ghost.png" width="400px"/>

<span>=</span>

<img class="border border-2" src="figures/mesh_all.png" width="400px"/>
:::

## Algebra of sets

:::{.text-center}
<img class="border border-2" src="figures/mesh_all.png" width="400px"/><span>\\</span>
<img class="border border-2" src="figures/mesh.png" width="400px"/>

<span>=</span>

<img class="border border-2" src="figures/mesh_ghost.png" width="400px"/>
:::

## Algebra of sets

The search of an admissible set is recursive. The algorithm starts from the last dimension (y in 2d, z in 3d,...).

The available operators in samurai are for now

- the <span>intersection</span> of sets,
- the <span>union</span> of sets,
- the <span>difference</span> between two sets,
- the <span>translation</span> of a set,
- the <span>extension</span> of a set.

## Algebra of sets: Usage to MRA

<div>
<video src="videos/mra_construction/mesh_0000_unnamed.mp4" />
</div>

:::{.text-center .mt-0}
initial mesh
:::

## Algebra of sets: Usage to MRA

<div>
<video data-autoplay src="videos/mra_construction/mesh_0000_unnamed.mp4" />
</div>

:::{.text-center .mt-0}
initial mesh
:::

## Algebra of sets: Usage to MRA

<div>
<video data-autoplay src="videos/mra_construction/mesh_0001_unnamed.mp4" />
</div>

:::{.text-center .mt-0}
ghost cells used by the numerical scheme
:::

## Algebra of sets: Usage to MRA

<div>
<video data-autoplay src="videos/mra_construction/mesh_0002_unnamed.mp4" />
</div>

:::{.text-center .mt-0}
cells needed to compute the details (all tree)
:::


## Algebra of sets: Usage to MRA

<div>
<video data-autoplay src="videos/mra_construction/mesh_0003_unnamed.mp4" />
</div>

:::{.text-center .mt-0}
cells needed to compute the details (iterative way)
:::

## Algebra of sets: Usage to MRA

<div>
<video data-autoplay src="videos/mra_construction/mesh_0004_unnamed.mp4" />
</div>

:::{.text-center .mt-0}
cells needed to compute the details (iterative way)
:::

## Algebra of sets: Usage to MRA

<div>
<video data-autoplay src="videos/mra_construction/mesh_0005_unnamed.mp4" />
</div>

:::{.text-center .mt-0}
cells needed to compute the details (iterative way)
:::

## Algebra of sets: Usage to MRA

<div>
<video data-autoplay src="videos/mra_construction/mesh_0006_unnamed.mp4" />
</div>

:::{.text-center .mt-0}
cells needed to compute the details (iterative way)
:::

## Algebra of sets: Usage to MRA

<div>
<video data-autoplay src="videos/mra_construction/mesh_0007_unnamed.mp4" />
</div>

:::{.text-center .mt-0}
cells needed to compute the details (iterative way)
:::

## Meshes description with samurai

Given a mesh with all the leaves called `cells`

- ghosts for the numerical scheme

<!-- $$
ghosts^l = \text{extend} \; cells^l \; \text{about the stencil size in each direction}
$$ -->

```{.cpp}
samurai::for_each_interval(mesh[cells], [&](std::size_t level, auto& i)
{
    mesh[cells_and_ghosts][level].add_interval({i.start - stencil_size, i.end + stencil_size});
})
```

## Meshes description with samurai

Given a mesh with all the leaves called `cells`

- ghosts for the detail computation

```{.cpp}
for(std::size_t level = min_level + 1; level <= max_level; ++level)
{
    auto subset = difference(mesh[cells_and_ghosts][level], union()[level]);

    subset([&](std::size_t level, auto& i)
    {
        auto i_above = i >> 1;
        mesh[pred][level - 1].add_interval({i_above.start - prediction_size, i_above.end + prediction_size});
    })
}
```


```{.cpp}
for(std::size_t level = min_level + 2; level <= max_level; ++level)
{
    samurai::for_each_interval(mesh[cells][level], [&](std::size_t level, auto& i)
    {
        auto i_above = i >> 2;
        mesh[pred][level - 2].add_interval({i_above.start - prediction_size, i_above.end + prediction_size});
    })
}
```

## Meshes description with samurai

Given a mesh with all the leaves called `cells`

- ghosts where we apply the projection

```{.cpp}
for(std::size_t level = min_level; level < max_level; ++level)
{
    auto subset = intersection(mesh[reference][level], union()[level]).on(level+1);
    subset([&](std::size_t level, auto& i)
    {
        mesh[reference][level + 1].add_interval(i);
        mesh[proj][level].add_interval(i >> 1);
    })
}
```



## Compression rates

![](figures/p4est_3.png)

## Compression rates

::: {.fs-5}
| Level | Num. of cells | p4est       | samurai (leaves) | samurai (all) | ratio  |
|-------|---------------|-------------|------------------|---------------|--------|
| $9$   | 66379         | 2.57 Mb     | 33.68 Kb         | 121 Kb        | 21.24  |
| $10$  | 263767        | 10.25 Mb    | 66.64 Kb         | 236.8 Kb      | 43.28  |
| $11$  | 1051747       | 40.96 Mb    | 132.36 Kb        | 467.24 Kb     | 87.66  |
| $12$  | 4200559       | 163.75 Mb   | 263.6 Kb         | 927 Kb        | 176.64 |
| $13$  | 16789627      | 654.86 Mb   | 525.9 Kb         | 1.85 Mb       | 353.98 |
| $14$  | 67133575      | 2.61 Gb     | 1.05 Mb          | 3.68 Mb       | 709.24 |
:::

## Other features

- Loop algorithms over the levels and the cells
- Simplified access operator
- Helper classes to construct complex meshes
- Helper classes to construct schemes for explicit and implicit usage
- Helper classes to construct N-D operators and expressions using xtensor
- HDF5 support

<!-- {{< include examples.qmd >}} -->
<!-- {{< include splitting_imex.qmd >}} -->

## Key point

:::{.text-center}
Implement your finite volume scheme on a uniform Cartesian grid

and

<span>you have explicit and implicit at your disposal</span></p>

<span>you have a large range of time schemes available</span>

<span>you have the adaptation (MRA / AMR) without further effort</span>

<span>you have parallelism</span>

:::

## Roadmap

![](figures/roadmap.png)

---

:::{.row .align-items-center}
::::{.col-4}
<video data-autoplay loop="true" src="videos/ink.mp4" />
::::
::::{.col}
![](figures/human.png)
::::
::::{.col-5}
![](figures/lbm_test_case.png)
::::
:::

:::{.row .align-items-center}
::::{.col-4}
<video data-autoplay loop="true" src="videos/bubble.mp4" />::::
::::{.col}
![](figures/plasma.png)
::::
:::
